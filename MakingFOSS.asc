Why Make Open Source Software?
------------------------------

Software is surprisingly dynamic.  All software evolves.  Bugs are found and fixed.  Enhancements added.  New requirements are discovered in using the software.  New uses are found for it and it is shaped to those new uses.  Software solutions that are useful and used must by their very existence evolve.   Well organized open source software communities create the right conditions to make this dynamism successful.

The world continues to embrace and adopt free and open source licensed software across the board.  Vendors and OEMs, their IT customers, governments and academics are all using, buying and making open source software, and often all three at once.

Using and buying liberally licensed open source software, i.e. consuming such software, are relatively straight forward affairs. You buy a product based on open source licensed software pretty much the way you buy other software, evaluating the company producing the products and services against your own IT requirements and managed procurement risk profiles.  You don’t procure Red Hat Linux server software differently than you historically bought Solaris or might buy Microsoft Windows Server systems.  

Using open source software (as opposed to buying a product) adds additional considerations based on evaluating the strength of the community around the open source project and the costs of supporting that choice either through the development of in-house expertise (likely supported by joining the project’s community) or the hiring of external expertise. You look at a project’s how-to documentation and tutorials, forum and email list activity, and IRC channels.  You consider the availability of contracting support from other knowledgeable sources around the community.  These considerations really don’t change whether the open source software to be used is tools and infrastructure systems or developer libraries and frameworks.  These considerations scale with use from individuals and the amount of time they have to spend solving their problem all the way up through company IT departments wanting to use open source licensed software and the time and money trade-offs they’re willing to make.

Once one starts to make open source software, i.e. producing it, a different set of considerations arise.  There are really two scenarios for producing open source:

* One can contribute to an existing project, adding value through bug fixes and new functionality (and possibly non-software contributions like documentation and translations).
* One can start a new open source project, which means organizing the infrastructure, developing the initial software, and providing for the early community.  

The motivation in the first case of contributing to an existing open source project is simple.  People generally start using open source software before they become contributors.  People use software because it solves a problem they have.   Once they use the software for a while, they will generally encounter a bug, find a change they want to make, or possibly document a new use case.  If the user is comfortable with making software changes and the project community has done a good job of making it easy to contribute, then contributions can happen.  

While it would be easy to simply make the necessary change and ignore the contribution, living on a personal forked copy of the software comes at a cost.  Others’ enhancements and bug fixes aren’t seen and shared by installing newer versions of the software, and one needs to re-patch the software with one’s own changes and fixes if one does try to move to a newer version.  It is far better to contribute one’s changes back to the project community if feasible, working with the committers to ensure its contributed correctly and patched into the main development tree. The onus is on the community to make it easy to contribute, but it’s on the contributor to contribute correctly.  The cost of living on a fork gets worse over time as the forked branch drifts further away from the mainline development of the project.  It is well worth the investment to contribute.  

This brings us to the “making” open source software case of starting one’s own project.  

First, it all starts with software.  You must consider the software itself around which a project and its community is to be built.  The software must “do” something useful from the beginning.  Open source software developer communities are predominantly a discussion that starts with code, and without the code their is no discussion.  Even when a fledgling community comes together to discuss a problem first with an eye to building the solution together, sooner or later someone needs to commit to writing the first workable building software that will act as a centre of gravity for all other conversations.  

If an existing body of software is to be published into an open source community then there needs to be certain considerations with respect to the ownership and licensing.  Software is covered by digital copyright and someone owns that copyright.  To publish existing software requires the owners to agree to the publication and licensing as open source.  The weight of existing code and its cultural history need to be considered, and may effect the early project community.   

The crucial question becomes “why” open source?  What motivates the publication of software under an open source license?  Why share the software?  Why choose NOT to commercialize it.  (There are a number of important reasons not to commercialize or keep the software proprietary.)

The economics of collaboratively developing software is compelling.  Writing good software is hard work.  Managing the evolution of software over time is equally hard work.  Sharing good software and collaboratively developing and maintaining it distributes the costs across a group.  Publishing the software as open source, and building a development community (however small) is motivated by a desire to evolve the software and share the value and to be open to the idea that others in the community will join in sharing their domain expertise, learning the software’s structure, and sharing the costs of evolution.  

The economics are also asymmetric.  For a contributor the contribution may represent a small bit of expertise from the contributor (e.g. a single bug fix or particular application of an algorithm that they personally understood), but the contributor is rewarded with the community investment of the entire package of software at relatively small personal cost.  Likewise, the contribution is valuable to the software’s developer (and user) community at large without necessarily carrying the costs of the contributor as a full time member in the developer community.  (Indeed a single contribution may have been the only value the contributor had to give in this instance.)  

Motivation to develop an open source community to evolve the software is an essential factor, but so too are knowledge of the problem domain, and the internal knowledge of the software needed to anchor the community.  The essential motivation to share the software as open source supports the commitment and investment to maintain enough domain expertise and software knowledge to keep the community going and growing.  Without all three factors it is difficult for the community to evolve the software and thrive.

One of the first structural considerations needs to be which open source software license to attach to the project.  There are an array of licenses that have been approved by the Open Source Initiative as supporting the Open Source Definition, but there are really just a few that typically need consideration, and we’ll discuss those at length in another post.  The important thing to realize when choosing a license is that it doesn’t just outline the legal responsibilities for how the software is shared, but it also outlines the social contract for how the community will share.  

The next structural consideration for a community is to choose a tool platform to support collaborative development.  This is the hub for activity for managing source code versions, distributing built software, handling the lines of communications, and logging issues and bugs.  There are a number of free forge sites (e.g. Codeplex, Google Code, GitHub, SourceForge), and the tools all exist as open source themselves if a project wanted to develop and manage its own site.  

The last structural consideration involves deciding what sort of community one wants to develop.  What sort of governance will be required and when will certain things need to be instituted.  There are two very good books available in this space:

* http://www.artofcommunityonline.org/[The Art of Community] by Jono Bacon
* http://producingoss.com/[Producing Open Source Software] by Karl Fogel

Contribution is the life blood of an open source software community.  It leads to new developers joining the project and learning enough to becoming committers with the responsibility for the code base and its builds.  Its what makes the shared economic cost work for all.  But as already stated, contributors generally start as users of the software.  This means that a project community hoping to attract contributors first needs to attract users.  The project’s initial participants need to build a solid onramp for users that can then become contributors by making the software easy to “use”, ensuring it’s discoverable, downloadable, easily installable, and quickly configurable.  

Not all users will contribute.  Some may never push the software enough to need to make a change.  It simply solves the problems they need to solve.  Of those that contribute, some will contribute in very simple ways, reporting bugs for particular use cases.   Others may contribute more, and this is where the second onramp needs to be developed by the community.  Contributors need to know what sorts of contributions are encouraged, how to contribute, and where to contribute.  If code contributions are to be encouraged, having scripts and notes on building the software and testing the baseline build make it easy for potential contributing developers to get involved.  

So building an open source software project follows a pattern:

* There needs to be useful software, at least a seed around which to build a community.
* Motivation to share, expertise in the problem to be solved, and an understanding of the software structure will anchor an open source community. The project founder is the starting point for what will hopefully become a community.
* The project needs to have the structural issues of license, forge, and governance sorted, even if governance becomes an evolving discussion in a growing community.
* The community needs to build a solid onramp for users, and a second onramp for contributors.  The sooner this happens in a project’s life, the faster it can build a community.

One can choose to publish software under an open source license and never build a community.  The software isn’t “lost”, but neither is it hardened or evolved.  It may be useful to someone that discovers it, but the dynamic aspects of software development are lost to it.  Taking the steps to encourage and build a community around the open source project sets the dynamic software engine in motion and allows the economics of collaborative development and sharing to work at its best.